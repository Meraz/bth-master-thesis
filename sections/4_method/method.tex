\documentclass[../../main.tex]{subfiles}
\begin{document}


% Two-scale
% RTS
% Combined


%%%%%%%%
\section{Two-scale}
%%%%%%%%
\textit{Brief description of two-scale and its key beneficial parts}

The two-scale method runs two simulations with two different particle sizes. The one with large particles, the low resolution L, is the base simulation and represents the whole fluid. The high resolution, H, represents a subset of the fluid, either user defined or dynamically decided. L is half the resolution of H and thus the L-particles are 8 times larger than the H-particles. This allows for a fewer amount of particles to represent a substantially larger area than would be possible without resizing them. Thus the simulation does not need as many particles which reduces the computation time. The region of higher resolution can be set where the details of the simulation is more important, like the surface, where the camera looks, or where obstacles are. 

Each H-particle keeps track of its parent particle in L. In the so called boundary region, H-particles are created and destroyed, depending on if their parent particle is entering or leaving the active region. When an L-particle enters the boundary region a set of smaller particles are created, these particles will be advected for as long as they are in a region with width Support radius, around the active region. We do not calculate physics on them since they need a full neighborhood to be correct. When the parent particle exit the boundary region and enter the real active region its child particles (which were previously just being advected) enter a relaxed state. The particles are in this state during a short period of time, during which we interpolate their quantities from their advected ones (the ones from their parent) to ones that they calculate on themselves (since they now have a full neighborhood). 

The L-particles in the active region receive feedback force from the smaller particles so that the different fluid simulations do not diverge significantly and because the higher resolution simulation has more details. 

For the sake of simplicity and because of time restraints we chose not to implement the surface detection algorithm.

We changed the velocity relaxation of particles by limiting the adding velocity instead of the total. The beta value is set to [VALUE] from experiments. 

%%%%%%%%
\section{RTS for PCISPH}
%%%%%%%%
In \cite{goswami2014regional} they define a virtual grid of three dimensional regions, called blocks. Each block is of the same size and each particle exist in exactly one block. The blocks are designed in such a way that if \textit{s} represents the initial particle spacing, then each block has a support radius \textit{r} such that \textit{r $\leq$ 2s}. The region-based time-step method is illustrated in Figure \ref{fig:regions} and can be explained in three steps:
\\
\\1. All particles compute their velocity and total force.
\\2. Particles conveys their attributes to their containing region. A minimum time step is computed for the region.
\\3. The time step is applied on every particle in that region. 
\\
The main objective of the method, to speed up the simulation, is accomplished by allowing each particle to get the largest possible time step while the physical accuracy still remains the same. This is accomplished with the assumption that liquid within small well defined boundaries are the subject of the same pressure and force. This infers that instead of using the same global time step for every particle we let each block calculate a lowest required sub-step based on particles within. Ideally this sub-step is of the same size as the current global time step, that is, as high as possible. However, some particles within some blocks may require a lower sub-step to obtain the visual result desired. 

The implementation for PCISPH is quite different from the WCSPH one. First there is a major step in which 4(eller olika) minor time steps are calculated. After the blocks get their region assigned each minor step is calculated consecutively. In each minor step all blocks enter the prediction-correction loop at least once and then calculate further iterations depending on the block's region membership. In the correction loop we also check if there are any particles which still have erroneous densities, these also receive more iterations. These iterations, however, are local and as such are only calculated on the relevant particles. After the loop all blocks calculate possible new memberships and all particles are then forwarded in time one deltaT seconds. 

There is also a set of marked boundary blocks which are blocks that lie between two time step regions and between error marked blocks and non-error blocks. The boundary blocks are observed for any density errors that might occur to previously correct blocks. 

To make sure that local corrections on error particles doesn't make things worse instead of better the simulation checks if local corrections are performed for more than 6 global iterations. If so the global time step is reduced to 2 deltaT (half of standard). The global time step is reverted if the simulation runs without exceeding 6 global correction iterations for 10 or more global time steps. 

For R1 particles, i.e. fast particles, a larger radius is used when calculating neighbors, using two blocks instead of one. This increases computation time a lot but is apparently necessary for stability and the R1 particles are few so it is OK. 

%The opening for multiple individual time-steps also conveys the possibility for creating a non-synchronized simulation. This could lead to undesired results as it implies that particles would not interact with each other in the same timeframe. This, however, is solved by the design of Algorithm \ref{alg:RegionalTime} which takes the synchronization into account (line 9). If any particle would ever transition faster in the simulation, because of a separate time step, they will have their following physics computations halted until they are synchronized once again.


%%%%%%%%
\section{Our method}
%%%%%%%%
%As illustrated in Figure \ref{fig:TwoPartLAndH} we adopt the idea of \cite{solenthaler2011two} where we compute the simulation in two distinct parts, the low resolution simulation L and the high resolution H. However, instead of performing the computation for L and H with a standard SPH or PCISPH we rather adopt the idea of \cite{goswami2014regional}. As such we subdivide the current simulation into blocks in such a way that each particle exist in exactly one block. Each block then calculates the lowest sub-step required for the particles within and performs necessary physical calculations using using the new sub-step. This implies that the idea of \cite{goswami2014regional}, illustrated as Algorithm \ref{alg:RegionalTime}, is performed once for L, the whole fluid, and then \textit{nSubSteps} times for H per iteration.

Based upon the RTS algorithm, we inserted the two-scale algorithm into the minor step for loop. Everything before the minor steps are the same, but is done for both the L- and the H-simulation. The DoPhysics in our combined algorithm corresponds to the original RTS minor step but we have moved both Determine regions and Update parent particle to outside the minor loop. We did this because they change the particle list in the H-simulation and therefore invalidates the neighborhood grid. Since we would like to update the neighborhood as seldom as possible we make sure that things that change it only happens once every major step. 

We are using the same constants for feedback force, pressure force interpolation, relax time and region conditions, maybe? Maybe this should be mentioned in some kind of implementation section?

Special prediction correction loop for the H simulation that does not calculate physics on boundary particles and has higher allowed density error for relaxed particles. Also applies to local corrections. 

Also, since we are expecting the relaxed particles to not behave physically correct we don't allow them to add their block to the error region. However, if an active particle and a relaxed particle is in the same block and the active particle is erroneous, that block will be marked and added to the error region and all particles within it (including the relaxed) will be further corrected. 

The halving of minor steps happen if one simulation, L or H, runs more than 6 local correction loops, according to Goswami. We allow the minor steps to reset only if both simulations manages to run less than 6 local corrections for 10 major steps. (kanske n책t om time integration, att partiklar forwardas 채ven fast det antagligen 채r fel, vet inte om det 채r viktigt?)

We found that the large neighborhood search was unnecessary for our implementation and the simulation got the same visual results but ran 30\% faster. 

%%%%%%%%
\subsection{Neighborhood search}
%%%%%%%%
{\color{red}How neighborhood search is done, if any changes.}
We are using the same neighborhood search as Goswami, except for the large neighbor search, and the index sort in "A parallel SPH implementation on multi-core CPUs", Ihmsen 2010. 

\subsection{High resolution determination}


\end{document}